[운영체제 : 정리5] 8~11

(본 자료는 한국 기술 교육 대학교 , 김덕수 교수님의 강의를 바탕으로 직접 정리 하였습니다.)

(https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN)

(https://sites.google.com/view/hpclab/courses/operating-system)



#### 프로세스 스케줄링



- 다중 프로그래밍
  - 여러개의 프로세스가 시스템 내에 존재 (ex. 유튜브로 음악들으면서 , 롤 하는 것은 최소 2개의 프로세스가 실행중, 롤 하나의 내에서는 롤만의 다양한 스레드가 존재)
  - 자원을 할당 할 프로세스를 선택해야함
    - 스케줄링
  - 자원관리
    - 시간 분할 관리
      -  하나의 자원을 여러 스레드들이 번갈아 가며 사용
      - 예) 프로세서
      - 프로세스 스케줄링
        - 프로세서 사용시간을 프로세스들에게 분배
    - 공간 분할 관리
      - 하나의 자원을 분할하여 동시에 사용
      - 예) 메모리



- 스케줄링의 목적
  - 시스템의 성능 향상
  - 대표적인 시스템 성능 지표
    - 응답시간
      - 작업 요청으로부터 응답을 받을때 까지의 시간
    - 작업 처리량 
      - 단위 시간동안 완료된 작업의 수
    - 자원 활용도
      - 주어진 시간동안 자원이 활용된 시간
  - 목적에 맞는 지표를 고려하여 스케줄링 기법을 선택
    - 예를들어 "응답시간"이 중요한 지표가 되는 작업은 -> 메신저와 같은 서비스
    - "작업 처리량"이 중요한 지표는 -> badge system에서 중요
  - 이외에도
    - 평균 응답시간
    - 처리량
    - 자원활용도
    - 공평성
    - 등 굉장히 많은 구분이 존재함



![20210323_114809](20210323_114809.png)



- 스케줄링의 기준
  - 스케줄링 기법이 고려하는 항목들
  - 프로세스의 특성
  - 시스템 특성
  - 프로세스의 긴급성
  - 프로세스 우선순위
  - 프로세스 총 실행시간



![20210323_115258](20210323_115258.png)

I/O는 input / output을 의미함



- cpu 사용시간이 더 많은 경우 computed bounded라고 일컬어짐
- i/o의 사용시간이 더 많은 경우 io bounded라고 일컬어짐



![20210323_115517](20210323_115517.png)



![20210323_115542](20210323_115542.png)



- 시스템 내에 프로세스가 너무 많으면 관리가 힘들어짐
- i/o bounded와 computed bounded를 잘 선택해야함
  - computed bounded만을 중심으로 사용한다면 cpu가 일하는 도중 i/o기기는 놀게됨
  - 역의 관계도 존재함 -> 시스템 입장에서 이는 매우 비효율적임
  - 둘을 잘 섞어서 활용해야 시스템의 효율성이 증가함
- 시분할 시스템에서는 long-term scheduling이 상대적으로 덜 중요하다가 적합한 표현



![20210323_120116](20210323_120116.png)

![20210323_120141](20210323_120141.png)

![20210323_120432](20210323_120432.png)



![20210323_120516](20210323_120516.png)



![20210323_120620](20210323_120620.png)



- 선점 -> 누군가 나의 자원을 뺴앗을 수 있다.
  - cpu 할당이 계속 바뀌기 때문에 overhead발생

- 비선점 -> 누군가 나의 자원을 빼앗을 수 없다.
  - 우선순위가 급한일이 들어왔는데도 급한일이 실행 안됨



![20210323_121019](20210323_121019.png)



- 우선순위가 한 번 정해지면 바뀌지 않는다. (static)
- 우선순위가 지속적으로 변한다. (dynamic)



![20210323_121310](20210323_121310.png)

- 우선순위가 실제로 사용되는걸 볼 수 있음



#### 기본 스케줄링 알고리즘

![20210323_121610](20210323_121610.png)

![20210323_121643](20210323_121643.png)



- ​	자원을 효율적으로 사용 가능
  - 스케줄링에 대한 overhead가 굉장히 적으며, 프로세서는 지속적으로 작업 가능
- batch system에 적합한 이유는 효율적으로 한번에 모아서 작업이 수행됨
- interactice system에 부적합한 이유는 지금 반응이 필요한데 바로 반응이 안 일어남



- 나는 2초면 되는데 , 내 앞에 스케줄링이 된 애가 3분이면 2초짜리 친구도 굉장히 늦게 완료됨
  - 이것을 convey effect라고 부름

- FCSS  효율성 지표

![20210324_111149](20210324_111149.png)





![20210324_111656](20210324_111656.png)

- 돌아가면서 시간을 사용하자.
- 내가 5초 너도 5초 이런식으로 사용
- 레디큐에 먼저 도착한 애를 먼저 실행시켜줌
- 자원 사용 제한 시간 -> time quantum
  - context switch의 추가적인 소요 시간이 매우 큼
- 대화형 시스템에 적합한 이유 -> 응답이 바로 바로 나와야 하므로
- 시분할 시스템에 적합함 
- 적절한 time quantum을 정해야함 -> time quantum이 무한대라면 fcss
  - time quantum이 0에 가가깝다면 모두 프로세서를 동시 사용하는 느낌은 들지만 context swicth가 미친듯이 발생함

![20210324_112219](20210324_112219.png)

- Round-Robin의 주의할 점 -> 자신의 차례가 끝나면 다시 바로 맨 뒤에 가서 줄에 섬

![20210324_113410](20210324_113410.png)



#### SPN

![20210324_113642](20210324_113642.png)



![20210324_113836](20210324_113836.png)



- Bt가 큰 프로세스는 최악의 경우 실행이 되지 못할 수 있음
- Bt를 미리 알아야 함 -> 처음에 바로 예측할 수 있어야 함 -> terminate상태가 존재했는데 여기서 얻었던 정보들을 바탕으로 예측하기

![20210324_114433](20210324_114433.png)



![20210324_114513](20210324_114513.png)

- Bt 예측이 어렵고, 잔여실행 추적(overhead)의 발생

![20210324_114720](20210324_114720.png)





#### HRRN

![20210324_114754](20210324_114754.png)



- Aging concepts가 활용됨 -> 들어온지 오래된 일을 배려하자.
- waiting time을 고려하겠다
- 오래된 애일 수록 WT가 증가함
- 내가 필요한 시간대비 얼마나 기다렸는가를 나타냄
- 여전히 BT를 알아야한다는 문제점이 존재



#### MLQ

![20210324_115712](20210324_115712.png)



- MLQ라고 해서 꼭 빠르지 않음
  - 우선순위가 높은 큐에 있는 일들은 빠르게 작업되고, 낮은 큐에 있는 일들은 느리게 진행됨

![20210324_115945](20210324_115945.png)



#### MFQ

![20210324_120050](20210324_120050.png)



- 우선순위가 동적으로 이루어짐
- 누구를 올려줄지 내려줄지를 판단하는건 뒤에서 배움

![20210324_120209](20210324_120209.png)



![20210324_120226](20210324_120226.png)



io bounded를 빠르게 위로 올려주는 이유는 io bounded의 작업은 매우 빠르게 해결되기 때문에

![20210324_120445](20210324_120445.png)

